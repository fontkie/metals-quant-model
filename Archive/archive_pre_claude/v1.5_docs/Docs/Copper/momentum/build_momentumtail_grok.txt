import pandas as pd
import numpy as np
from datetime import datetime
import os

# File paths
price_file = r'C:\Code\Metals\Data\copper\pricing\pricing_values.xlsx'
vol_file = r'C:\Code\Metals\Data\copper\pricing\vol_values.xlsx'
output_dir = r'C:\Code\Metals\outputs\Copper\momentum'
output_file = os.path.join(output_dir, 'daily_series.csv')

# Create output dir if not exists
os.makedirs(output_dir, exist_ok=True)

# Load data
df_price = pd.read_excel(price_file, sheet_name='Raw')
df_vol = pd.read_excel(vol_file, sheet_name='Sheet1')

# Convert Excel serial dates to datetime
def excel_to_datetime(serial):
    return pd.to_timedelta(serial, unit='D') + datetime(1899, 12, 30)

df_price['Date'] = excel_to_datetime(df_price['Date'])
df_vol['Date'] = excel_to_datetime(df_vol['Date'])

# Select relevant columns (Col A: Date, Col D: copper_lme_3mo for price; Col A: Date, Col C: copper_lme_3mo_impliedvol for vol)
df = df_price[['Date', 'copper_lme_3mo']].copy()
df = df.merge(df_vol[['Date', 'copper_lme_3mo_impliedvol']], on='Date', how='left')
df = df.rename(columns={'copper_lme_3mo': 'Price', 'copper_lme_3mo_impliedvol': 'implied_vol3mo'})
df = df.sort_values('Date').reset_index(drop=True)
df = df.dropna(subset=['Price'])  # Drop NaN prices

# Compute returns
df['ret'] = df['Price'].pct_change()

# Parameters
breakout_window = 252
exit_window = 126
atr_lookback = 20
overshoot_multiple = 0.5
atr_multiple_trailing = 2.0
vol_z_lookback = 252
vol_z_threshold = 0.0
ann_target_vol = 0.10
vol_lookback_days = 21
leverage_cap = 2.5
one_way_bps = 1.5 / 10000  # 1.5 bps

# Compute ATR (close-to-close since no OHLC)
df['log_ret'] = np.log(1 + df['ret'])
df['atr20'] = df['Price'].shift(1) * df['log_ret'].rolling(atr_lookback).std() * np.sqrt(atr_lookback)

# Donchian channels
df['donch_high_prev'] = df['Price'].rolling(breakout_window).max().shift(1)
df['donch_low_prev'] = df['Price'].rolling(exit_window).min().shift(1)

# Vol z-score
df['vol_mean252'] = df['implied_vol3mo'].rolling(vol_z_lookback).mean()
df['vol_std252'] = df['implied_vol3mo'].rolling(vol_z_lookback).std()
df['vol_zscore252'] = (df['implied_vol3mo'] - df['vol_mean252']) / df['vol_std252']
# Optional: To increase trades in early periods, uncomment to treat NaN vol as passing gate
# df['vol_zscore252'] = df['vol_zscore252'].fillna(0.1)

# Entry signal
df['overshoot'] = (df['Price'] - df['donch_high_prev']) >= overshoot_multiple * df['atr20']
df['breakout'] = df['Price'] > df['donch_high_prev']
df['vol_gate'] = df['vol_zscore252'] > vol_z_threshold
df['signal'] = df['breakout'] & df['overshoot'] & df['vol_gate'] & ~df['implied_vol3mo'].isna()

# Position logic (long only, no re-entry while holding)
df['position'] = 0.0
df['trailing_high'] = np.nan
df['trailing_stop_level'] = np.nan
holding = False
current_trailing_high = np.nan
for i in range(max(breakout_window, vol_z_lookback) + 1, len(df)):
    if not holding and df.loc[i, 'signal']:
        df.loc[i, 'position'] = 1.0
        holding = True
        current_trailing_high = df.loc[i, 'Price']
        df.loc[i, 'trailing_high'] = current_trailing_high
        df.loc[i, 'trailing_stop_level'] = current_trailing_high - atr_multiple_trailing * df.loc[i, 'atr20']
    elif holding:
        df.loc[i, 'position'] = 1.0
        if df.loc[i, 'Price'] > current_trailing_high:
            current_trailing_high = df.loc[i, 'Price']
        df.loc[i, 'trailing_high'] = current_trailing_high
        df.loc[i, 'trailing_stop_level'] = current_trailing_high - atr_multiple_trailing * df.loc[i, 'atr20']
        if (df.loc[i, 'Price'] < df.loc[i, 'donch_low_prev']) or (df.loc[i, 'Price'] < df.loc[i, 'trailing_stop_level']):
            df.loc[i, 'position'] = 0.0
            holding = False
    else:
        df.loc[i, 'position'] = 0.0

# Sizing: vol targeting
df['rv21'] = df['ret'].rolling(vol_lookback_days).std() * np.sqrt(252)
df['lev_raw'] = ann_target_vol / df['rv21'].clip(lower=1e-8)
df['lev'] = df['lev_raw'].clip(upper=leverage_cap)

# Position for ret_t (lag)
df['pos_for_ret_t'] = df['position'].shift(1) * df['lev'].shift(1)

# Trading costs
df['turnover'] = np.abs(df['position'] - df['position'].shift(1))
df['trading costs'] = df['turnover'].shift(1) * one_way_bps * df['lev'].shift(1)

# Daily return
df['daily return'] = df['pos_for_ret_t'] * df['ret'] - df['trading costs']

# Equity curve (cumprod, starting at 1)
df['equity'] = (1 + df['daily return']).cumprod()

# Select columns for output
output_cols = ['Date', 'Price', 'ret', 'signal', 'position', 'daily return', 'trading costs', 'equity']
df_output = df[output_cols]

# Save to CSV
df_output.to_csv(output_file, index=False)
print(f'Output saved to {output_file}')